{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction a sample tutorial developing nodejs and deploy it to IBM Cloud Private 3.2.0 which is based on Kubernetes.","title":"Introduction"},{"location":"#introduction","text":"a sample tutorial developing nodejs and deploy it to IBM Cloud Private 3.2.0 which is based on Kubernetes.","title":"Introduction"},{"location":"about/","text":"Jaric Sng LinkedIn Acclaim","title":"About"},{"location":"go/","text":"setup go Visit the official Go downloads page and find the URL for the current binary release's tarball, along with its SHA256 hash. cd ~ curl -O https://dl.google.com/go/go1.12.7.linux-amd64.tar.gz sha256sum go1.12.7.linux-amd64.tar.gz extract the tarball tar xvf go1.12.7.linux-amd64.tar.gz Recursively change go's owner and group to root, and move it to /usr/local sudo chown -R root:root ./go sudo mv go /usr/local Note : Although /usr/local/go is the officially-recommended location, some users may prefer or require different paths. set some paths in your environment sudo vi ~/.profile At the end of the file, add this line: export GOPATH=$HOME/work export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin refresh your profile by running source ~/.profile Create a new directory for your Go workspace, which is where Go will build its files mkdir $HOME/work check go version go version create a directory hierarchy in this folder through this command in order for you to create your test file. You can replace the value user with your GitHub username if you plan to use Git to commit and store your Go code on GitHub mkdir -p work/src/github.com/user/hello create a sample \"hello world\" go file. touch ~/work/src/github.com/user/hello/hello.go copy the following into the hello.go file package main import \"fmt\" func main() { fmt.Printf(\"hello, world\\n\") } compile it by invoking the Go command install go install github.com/user/hello With the file compiled, you can run it by simply executing the command hello You can see where the compiled hello binary is installed by using the which command which hello You are all set to develop go.","title":"go"},{"location":"go/#setup-go","text":"Visit the official Go downloads page and find the URL for the current binary release's tarball, along with its SHA256 hash. cd ~ curl -O https://dl.google.com/go/go1.12.7.linux-amd64.tar.gz sha256sum go1.12.7.linux-amd64.tar.gz extract the tarball tar xvf go1.12.7.linux-amd64.tar.gz Recursively change go's owner and group to root, and move it to /usr/local sudo chown -R root:root ./go sudo mv go /usr/local Note : Although /usr/local/go is the officially-recommended location, some users may prefer or require different paths. set some paths in your environment sudo vi ~/.profile At the end of the file, add this line: export GOPATH=$HOME/work export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin refresh your profile by running source ~/.profile Create a new directory for your Go workspace, which is where Go will build its files mkdir $HOME/work check go version go version create a directory hierarchy in this folder through this command in order for you to create your test file. You can replace the value user with your GitHub username if you plan to use Git to commit and store your Go code on GitHub mkdir -p work/src/github.com/user/hello create a sample \"hello world\" go file. touch ~/work/src/github.com/user/hello/hello.go copy the following into the hello.go file package main import \"fmt\" func main() { fmt.Printf(\"hello, world\\n\") } compile it by invoking the Go command install go install github.com/user/hello With the file compiled, you can run it by simply executing the command hello You can see where the compiled hello binary is installed by using the which command which hello You are all set to develop go.","title":"setup go"},{"location":"hands-on/","text":"The hands-on tutorial will covers different programming languages over times. Currently, it includes the following where you will learn to build docker image and push to a Kubernetes cluster, IBM Cloud Private. The concept you learnt here is equally applicable in other Kubernetes platform. nodejs","title":"Hands on"},{"location":"java/","text":"","title":"Java"},{"location":"k3s/","text":"Pre requisite to setup centos with OpenShift aka OKD, you need to have - internet access - download and install the following - virtualbox - vagrant prepare in your host machine create a folder of choice create a file Vagrantfile copy the content into the Vagrantfile created above. start the machine a new VM will be provisined with the following command, it will read the Vagrantfile and provision the VM accordingly. vagrant up to use k3s in VM login to VM vagrant ssh list k3s nodes k3s kubectl get node to check id and password of k3s you can get the id and password to login k3s view it in more /etc/rancher/k3s/k3s.yaml more /etc/rancher/k3s/k3s.yaml to access k3s outside of VM (from your host) use a browser from your host and access https://localhost:6443 enter the id and password obtained in file /etc/rancher/k3s/k3s.yaml","title":"Deploy K3S in centos"},{"location":"k3s/#pre-requisite","text":"to setup centos with OpenShift aka OKD, you need to have - internet access - download and install the following - virtualbox - vagrant","title":"Pre requisite"},{"location":"k3s/#prepare-in-your-host-machine","text":"create a folder of choice create a file Vagrantfile copy the content into the Vagrantfile created above.","title":"prepare in your host machine"},{"location":"k3s/#start-the-machine","text":"a new VM will be provisined with the following command, it will read the Vagrantfile and provision the VM accordingly. vagrant up","title":"start the machine"},{"location":"k3s/#to-use-k3s-in-vm","text":"login to VM vagrant ssh","title":"to use k3s in VM"},{"location":"k3s/#list-k3s-nodes","text":"k3s kubectl get node","title":"list k3s nodes"},{"location":"k3s/#to-check-id-and-password-of-k3s","text":"you can get the id and password to login k3s view it in more /etc/rancher/k3s/k3s.yaml more /etc/rancher/k3s/k3s.yaml","title":"to check id and password of k3s"},{"location":"k3s/#to-access-k3s-outside-of-vm-from-your-host","text":"use a browser from your host and access https://localhost:6443 enter the id and password obtained in file /etc/rancher/k3s/k3s.yaml","title":"to access k3s outside of VM (from your host)"},{"location":"loopback/","text":"Loopback 4 Loopback is nodejs framework with TypeScript where you can develop API application fast using Swagger and OpenAPI. to develop loopback 4 you will need nodejs and npm, ensure you have both nodejs and npm installed, refer to nodejs setup . Install LoopBack 4 CLI sudo npm install -g @loopback/cli creaet a loopback project lb4 app answer the prompt as follows [?] Project name: getting-started [?] Project description: Getting started tutorial [?] Project root directory: (getting-started) [?] Application class name: StarterApplication [?] Select project build settings: Enable eslint, Enable prettier, Enable mocha, Enable loopbackBuild test the proejct cd getting-started npm start your own controller lb4 controller [?] Controller class name: hello [?] What kind of controller would you like to generate? Empty Controller create src/controllers/hello.controller.ts update src/controllers/index.ts Controller Hello was now created in src/controllers/ Paste the following contents into the file /src/controllers/hello.controller.ts. import {get} from '@loopback/rest'; export class HelloController { @get('/hello') hello(): string { return 'Hello world!'; } } Test your application npm start access http://192.168.64.7:3000/hello with your browser and you should see \" Hello world! \". build docker image docker build . -t getting-started:1.0 run the image docker run -p 5000:3000 getting-started:1.0 verify the application is running using http://192.168.64.7:5000/hello with browser assuming 192.168.64.7 is the IP of the multipass VM. Once the application is verified running as docker locally, you can tag your image and push to ICP accordingly. refer to nodejs sample. checkout getting started on loopback.","title":"loopback"},{"location":"loopback/#loopback-4","text":"Loopback is nodejs framework with TypeScript where you can develop API application fast using Swagger and OpenAPI. to develop loopback 4 you will need nodejs and npm, ensure you have both nodejs and npm installed, refer to nodejs setup . Install LoopBack 4 CLI sudo npm install -g @loopback/cli creaet a loopback project lb4 app answer the prompt as follows [?] Project name: getting-started [?] Project description: Getting started tutorial [?] Project root directory: (getting-started) [?] Application class name: StarterApplication [?] Select project build settings: Enable eslint, Enable prettier, Enable mocha, Enable loopbackBuild test the proejct cd getting-started npm start your own controller lb4 controller [?] Controller class name: hello [?] What kind of controller would you like to generate? Empty Controller create src/controllers/hello.controller.ts update src/controllers/index.ts Controller Hello was now created in src/controllers/ Paste the following contents into the file /src/controllers/hello.controller.ts. import {get} from '@loopback/rest'; export class HelloController { @get('/hello') hello(): string { return 'Hello world!'; } } Test your application npm start access http://192.168.64.7:3000/hello with your browser and you should see \" Hello world! \".","title":"Loopback 4"},{"location":"loopback/#build-docker-image","text":"docker build . -t getting-started:1.0 run the image docker run -p 5000:3000 getting-started:1.0 verify the application is running using http://192.168.64.7:5000/hello with browser assuming 192.168.64.7 is the IP of the multipass VM. Once the application is verified running as docker locally, you can tag your image and push to ICP accordingly. refer to nodejs sample. checkout getting started on loopback.","title":"build docker image"},{"location":"minishift/","text":"Minishift for Mac (virtualbox) Ensure you have installed virtualbox internet access installed brew minishift from a mac terminal, run the following command, a VM will be started after installation with a link to access the minishift console. install brew cask install minishift start minishift start --vm-driver virtualbox stop minishift stop To explore do refer to Using Minishift Resources Learn OpenShift to use minishift in other environment","title":"Deploy minishift"},{"location":"minishift/#minishift-for-mac-virtualbox","text":"Ensure you have installed virtualbox internet access installed brew","title":"Minishift for Mac (virtualbox)"},{"location":"minishift/#minishift","text":"from a mac terminal, run the following command, a VM will be started after installation with a link to access the minishift console.","title":"minishift"},{"location":"minishift/#install","text":"brew cask install minishift","title":"install"},{"location":"minishift/#start","text":"minishift start --vm-driver virtualbox","title":"start"},{"location":"minishift/#stop","text":"minishift stop To explore do refer to Using Minishift","title":"stop"},{"location":"minishift/#resources","text":"Learn OpenShift to use minishift in other environment","title":"Resources"},{"location":"nodejs/","text":"Introduction In this tutorial, you will learn how to build a docker image how to push an image to a private repo how to deploy an container in kubernetes platform About the application this is a nodejs application that calls httpbin.org API and you can then use Clone the project which contains the nodeJS that call service in httpbin.org High level steps develop app test it build docker image test it: docker run image docker tag (for target image repo) docker push download ICP cli tools: cloudctl and kubectl cloudctl login run in k8s: kubectl apply - yaml To do this tutorial, we will use a Linux CentOS. If you do not have a Linus O/S, do the following, on your host O/S download and install virtualbox in your host O/S download and install vagrant in your host O/S create a folder of choice and create a file Vagrantfile with the following content . run vagrant up and a centos will be provisioned using the Vagrantfile with VirtualBox. run `vagrant ssh to login to the provisioned centos In the CentOS, you will do the following steps git clone https://github.com/ibmcloudprivate2/httpbin-wrapper.git setup insecure docker login setup hosts file install nodejs app test the nodejs app build image tag the image push the image to ICP image repo run the image in ICP In centos setup insecure docker login setup insecure docker login to ICP repo, edit /etc/docker/daemon.json to include the following { \"insecure-registries\": [\"mycluster.icp:8500\"] } restart docker sudo systemctl restart docker verify docker docker run hello-world setup hosts file edit /etc/hosts to map mycluster.icp to ICP IP address and configure docker to use insecure login assuming ICP IP: 161.222.28.45 , add the following into /etc/hosts 161.222.28.45 mycluster.icp clone the tutorial project run the following command to clone the git project git clone https://github.com/ibmcloudprivate2/httpbin-wrapper.git cd httpbin-wrapper cp .env.sample .env verify nodejs and npm are installed node -v v10.16.3 npm -v 6.9.0 install the application npm install npm test > ls@1.0.0 test /home/vagrant/httpbin-wrapper > nyc mocha -r dotenv/config --exit --timeout 10000 Your port is: 1323 Running on http:/0.0.0.0:1323 API Tests # Test root context with defined url and uri getURL: https://httpbin.org/delay/1 context /: 200 { args: {}, data: '', files: {}, form: {}, headers: { Accept: 'application/json', Host: 'httpbin.org' }, origin: '219.83.38.2, 219.83.38.2', url: 'https://httpbin.org/delay/1' } \u2713 should be access to target url and uri (2136ms) # Test readiness getURL: https://httpbin.org/status/200 context /readiness: 200 {} \u2713 should be ready (1188ms) # Test liveness getURL: https://httpbin.org/status/200 context /liveness: 200 {} \u2713 should be alive (1167ms) # Test status 200 getURL: https://httpbin.org/status/200 context /status200: 200 {} \u2713 should be status 200 (1080ms) # Test status 503 getURL: https://httpbin.org/status/503 context /status503: 503 {} \u2713 should be status 503 (2108ms) # Test delay 1 sec getURL: https://httpbin.org/delay/1 context /delay1: 200 { args: {}, data: '', files: {}, form: {}, headers: { Accept: 'application/json', Host: 'httpbin.org' }, origin: '219.83.38.2, 219.83.38.2', url: 'https://httpbin.org/delay/1' } \u2713 should be delay 1 sec (3033ms) # Test delay 5 sec getURL: https://httpbin.org/delay/5 context /delay5: 200 { args: {}, data: '', files: {}, form: {}, headers: { Accept: 'application/json', Host: 'httpbin.org' }, origin: '219.83.38.2, 219.83.38.2', url: 'https://httpbin.org/delay/5' } \u2713 should be delay 5 sec (7250ms) 7 passing (18s) -----------|----------|----------|----------|----------|-------------------| File | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s | -----------|----------|----------|----------|----------|-------------------| All files | 83.33 | 50 | 88.24 | 92.31 | | config.js | 100 | 100 | 100 | 100 | | server.js | 83.1 | 50 | 88.24 | 92.19 |... 15,116,117,120 | -----------|----------|----------|----------|----------|-------------------| check ip of your VM ip a test the appliation test the application node -r dotenv/config server.js & curl http://localhost:1323 getURL: https://httpbin.org/delay/1 context /: 200 {\"args\":{},\"data\":\"\",\"files\":{},\"form\":{},\"headers\":{\"Accept\":\"application/json\",\"Host\":\"httpbin.org\"},\"origin\":\"219.83.38.2, 219.83.38.2\",\"url\":\"https://httpbin.org/delay/1\"}[vagrant@node1 httpbin-wrapper] terminal the app, the process id with the following command. ps -ef | grep node vagrant 3181 1836 1 14:36 pts/0 00:00:00 node -r dotenv/config server.js vagrant 3195 1836 0 14:37 pts/0 00:00:00 grep --color=auto node kill 3181 build the image, specify image-name and image-tag of your choice. docker build . -t <image-name>:<image-tag> example docker build . -t js-nodeapp:1.0 test the docker image docker run -e CONTAINER_PORT='3000' -e TARGET_URL='https://httpbin.org/' -e TARGET_URI='delay/1' -p 5000:3000 <image-name>:<image-tag> example run the application as daemon (background) docker run -e CONTAINER_PORT='3000' -e TARGET_URL='https://httpbin.org/' -e TARGET_URI='delay/1' -d -p 5000:3000 js-nodeapp:1.0 list the docker running container docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a2c857faef87 js-nodeapp:1.0 \"docker-entrypoint...\" 3 minutes ago Up 3 minutes 0.0.0.0:5000->3000/tcp mystifying_snyder access the application, the above command forward host port 5000 to the internal application port 3000. curl http://localhost:5000 terminal docker running container docker kill a2c857faef87 tag the image for ICP image repository, use the namespace assigned to user. docker tag js-nodeapp:1.0 mycluster.icp:8500/<namespace>/<image-name>:<image-tag> example assuming user has access to namespace: auser01 docker tag js-nodeapp:1.0 mycluster.icp:8500/auser01/js-nodeapp:1.0 login and push the image to kubernetes platform docker login mycluster.icp:8500 docker push mycluster.icp:8500/auser01/js-nodeapp:1.0 run the image in ICP, update the httpbin.yaml to reference the image push to ICP repo accordingly. kubectl apply -f ./k8s/httpbin.yaml Further exercise modify the application tag image new version test it push image to kubernetes platform scale it update the application to new version of image rollback Resources using virtualbox and vagrant to practice nodejs deployment to ICP. IBM Code Patterns sample codes to many different area, AI, Blockchain, Data Science, DevOps, Machine learning, API Management and many others. IBM Architecture Centers provides Reference Architecture to for many different categores: multi cloud, hybrid cloud, AI, Microservice, Security, Service Management. kubectl Cheat Sheet IBM community helm chart community Helm chart stable and incubator community Operator application catalog Infrastructure as Code Terrform to multi cloud providers , IBM,OpenStack, AWS, Azure, Google, vmware and many more. Configuration as Code with Ansible or Chef OWASP Zed Attack Proxy ( ZAP ) tutorial . devops security aqua Code Quality and Security SonarQube uninstall nodejs and npm sudo yum remove -y nodejs npm setup virtualbox guest addition, run vagrant plugin install vagrant-vbguest to guest addition for the VM. IBM Skill gateways","title":"nodejs"},{"location":"nodejs/#introduction","text":"In this tutorial, you will learn how to build a docker image how to push an image to a private repo how to deploy an container in kubernetes platform","title":"Introduction"},{"location":"nodejs/#about-the-application","text":"this is a nodejs application that calls httpbin.org API and you can then use Clone the project which contains the nodeJS that call service in httpbin.org High level steps develop app test it build docker image test it: docker run image docker tag (for target image repo) docker push download ICP cli tools: cloudctl and kubectl cloudctl login run in k8s: kubectl apply - yaml To do this tutorial, we will use a Linux CentOS. If you do not have a Linus O/S, do the following, on your host O/S download and install virtualbox in your host O/S download and install vagrant in your host O/S create a folder of choice and create a file Vagrantfile with the following content . run vagrant up and a centos will be provisioned using the Vagrantfile with VirtualBox. run `vagrant ssh to login to the provisioned centos In the CentOS, you will do the following steps git clone https://github.com/ibmcloudprivate2/httpbin-wrapper.git setup insecure docker login setup hosts file install nodejs app test the nodejs app build image tag the image push the image to ICP image repo run the image in ICP","title":"About the application"},{"location":"nodejs/#in-centos","text":"","title":"In centos"},{"location":"nodejs/#setup-insecure-docker-login","text":"setup insecure docker login to ICP repo, edit /etc/docker/daemon.json to include the following { \"insecure-registries\": [\"mycluster.icp:8500\"] } restart docker sudo systemctl restart docker","title":"setup insecure docker login"},{"location":"nodejs/#verify-docker","text":"docker run hello-world","title":"verify docker"},{"location":"nodejs/#setup-hosts-file","text":"edit /etc/hosts to map mycluster.icp to ICP IP address and configure docker to use insecure login assuming ICP IP: 161.222.28.45 , add the following into /etc/hosts 161.222.28.45 mycluster.icp","title":"setup hosts file"},{"location":"nodejs/#clone-the-tutorial-project","text":"run the following command to clone the git project git clone https://github.com/ibmcloudprivate2/httpbin-wrapper.git cd httpbin-wrapper cp .env.sample .env","title":"clone the tutorial project"},{"location":"nodejs/#verify-nodejs-and-npm-are-installed","text":"node -v v10.16.3 npm -v 6.9.0","title":"verify nodejs and npm are installed"},{"location":"nodejs/#install-the-application","text":"npm install npm test > ls@1.0.0 test /home/vagrant/httpbin-wrapper > nyc mocha -r dotenv/config --exit --timeout 10000 Your port is: 1323 Running on http:/0.0.0.0:1323 API Tests # Test root context with defined url and uri getURL: https://httpbin.org/delay/1 context /: 200 { args: {}, data: '', files: {}, form: {}, headers: { Accept: 'application/json', Host: 'httpbin.org' }, origin: '219.83.38.2, 219.83.38.2', url: 'https://httpbin.org/delay/1' } \u2713 should be access to target url and uri (2136ms) # Test readiness getURL: https://httpbin.org/status/200 context /readiness: 200 {} \u2713 should be ready (1188ms) # Test liveness getURL: https://httpbin.org/status/200 context /liveness: 200 {} \u2713 should be alive (1167ms) # Test status 200 getURL: https://httpbin.org/status/200 context /status200: 200 {} \u2713 should be status 200 (1080ms) # Test status 503 getURL: https://httpbin.org/status/503 context /status503: 503 {} \u2713 should be status 503 (2108ms) # Test delay 1 sec getURL: https://httpbin.org/delay/1 context /delay1: 200 { args: {}, data: '', files: {}, form: {}, headers: { Accept: 'application/json', Host: 'httpbin.org' }, origin: '219.83.38.2, 219.83.38.2', url: 'https://httpbin.org/delay/1' } \u2713 should be delay 1 sec (3033ms) # Test delay 5 sec getURL: https://httpbin.org/delay/5 context /delay5: 200 { args: {}, data: '', files: {}, form: {}, headers: { Accept: 'application/json', Host: 'httpbin.org' }, origin: '219.83.38.2, 219.83.38.2', url: 'https://httpbin.org/delay/5' } \u2713 should be delay 5 sec (7250ms) 7 passing (18s) -----------|----------|----------|----------|----------|-------------------| File | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s | -----------|----------|----------|----------|----------|-------------------| All files | 83.33 | 50 | 88.24 | 92.31 | | config.js | 100 | 100 | 100 | 100 | | server.js | 83.1 | 50 | 88.24 | 92.19 |... 15,116,117,120 | -----------|----------|----------|----------|----------|-------------------|","title":"install the application"},{"location":"nodejs/#check-ip-of-your-vm","text":"ip a","title":"check ip of your VM"},{"location":"nodejs/#test-the-appliation","text":"test the application node -r dotenv/config server.js & curl http://localhost:1323 getURL: https://httpbin.org/delay/1 context /: 200 {\"args\":{},\"data\":\"\",\"files\":{},\"form\":{},\"headers\":{\"Accept\":\"application/json\",\"Host\":\"httpbin.org\"},\"origin\":\"219.83.38.2, 219.83.38.2\",\"url\":\"https://httpbin.org/delay/1\"}[vagrant@node1 httpbin-wrapper] terminal the app, the process id with the following command. ps -ef | grep node vagrant 3181 1836 1 14:36 pts/0 00:00:00 node -r dotenv/config server.js vagrant 3195 1836 0 14:37 pts/0 00:00:00 grep --color=auto node kill 3181 build the image, specify image-name and image-tag of your choice. docker build . -t <image-name>:<image-tag> example docker build . -t js-nodeapp:1.0 test the docker image docker run -e CONTAINER_PORT='3000' -e TARGET_URL='https://httpbin.org/' -e TARGET_URI='delay/1' -p 5000:3000 <image-name>:<image-tag> example run the application as daemon (background) docker run -e CONTAINER_PORT='3000' -e TARGET_URL='https://httpbin.org/' -e TARGET_URI='delay/1' -d -p 5000:3000 js-nodeapp:1.0 list the docker running container docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a2c857faef87 js-nodeapp:1.0 \"docker-entrypoint...\" 3 minutes ago Up 3 minutes 0.0.0.0:5000->3000/tcp mystifying_snyder access the application, the above command forward host port 5000 to the internal application port 3000. curl http://localhost:5000 terminal docker running container docker kill a2c857faef87 tag the image for ICP image repository, use the namespace assigned to user. docker tag js-nodeapp:1.0 mycluster.icp:8500/<namespace>/<image-name>:<image-tag> example assuming user has access to namespace: auser01 docker tag js-nodeapp:1.0 mycluster.icp:8500/auser01/js-nodeapp:1.0 login and push the image to kubernetes platform docker login mycluster.icp:8500 docker push mycluster.icp:8500/auser01/js-nodeapp:1.0 run the image in ICP, update the httpbin.yaml to reference the image push to ICP repo accordingly. kubectl apply -f ./k8s/httpbin.yaml","title":"test the appliation"},{"location":"nodejs/#further-exercise","text":"modify the application tag image new version test it push image to kubernetes platform scale it update the application to new version of image rollback","title":"Further exercise"},{"location":"nodejs/#resources","text":"using virtualbox and vagrant to practice nodejs deployment to ICP. IBM Code Patterns sample codes to many different area, AI, Blockchain, Data Science, DevOps, Machine learning, API Management and many others. IBM Architecture Centers provides Reference Architecture to for many different categores: multi cloud, hybrid cloud, AI, Microservice, Security, Service Management. kubectl Cheat Sheet IBM community helm chart community Helm chart stable and incubator community Operator application catalog Infrastructure as Code Terrform to multi cloud providers , IBM,OpenStack, AWS, Azure, Google, vmware and many more. Configuration as Code with Ansible or Chef OWASP Zed Attack Proxy ( ZAP ) tutorial . devops security aqua Code Quality and Security SonarQube uninstall nodejs and npm sudo yum remove -y nodejs npm setup virtualbox guest addition, run vagrant plugin install vagrant-vbguest to guest addition for the VM. IBM Skill gateways","title":"Resources"},{"location":"okd/","text":"Pre requisite to setup centos with OpenShift aka OKD, you need to have - internet access - download and install the following - virtualbox - vagrant prepare in your host machine create a folder of choice create a file Vagrantfile copy the content into the Vagrantfile created above. OKD setup using vagrant it will start up and install the following. git ansible docker wget python pip okd 3.11 start up the cluster start the machine a new VM will be provisined with the following command, it will read the Vagrantfile and provision the VM accordingly. vagrant up access the okd console in browser from your host machine, login id: developer pw: any value https://127.0.0.1:8443 using on shutdown. you can start your okd centos again vagrant up login to centos shell vagrant ssh within the centos shell, to start the okd cluster again oc cluster up Resources install docker-ce in centos install python issue: SELinux is not supported with the overlay2 graph driver on this kernel. solution","title":"Deploy a OKD 3.11 in centos"},{"location":"okd/#pre-requisite","text":"to setup centos with OpenShift aka OKD, you need to have - internet access - download and install the following - virtualbox - vagrant","title":"Pre requisite"},{"location":"okd/#prepare-in-your-host-machine","text":"create a folder of choice create a file Vagrantfile copy the content into the Vagrantfile created above.","title":"prepare in your host machine"},{"location":"okd/#okd-setup","text":"using vagrant it will start up and install the following. git ansible docker wget python pip okd 3.11 start up the cluster","title":"OKD setup"},{"location":"okd/#start-the-machine","text":"a new VM will be provisined with the following command, it will read the Vagrantfile and provision the VM accordingly. vagrant up","title":"start the machine"},{"location":"okd/#access-the-okd-console-in-browser","text":"from your host machine, login id: developer pw: any value https://127.0.0.1:8443","title":"access the okd console in browser"},{"location":"okd/#using-on-shutdown","text":"you can start your okd centos again vagrant up login to centos shell vagrant ssh within the centos shell, to start the okd cluster again oc cluster up","title":"using on shutdown."},{"location":"okd/#resources","text":"install docker-ce in centos install python issue: SELinux is not supported with the overlay2 graph driver on this kernel. solution","title":"Resources"},{"location":"php/","text":"","title":"Php"},{"location":"prepare/","text":"Development environment Level: Beginner Ensure your development environment has the following docker where you can build, run, push/pull images install node and npm IBM Cloud Private tools install cloudctl install kubectl In this tutorial, we will be doing our docker development on Ubuntun 18.04 and we will create a ubuntu VM on your machine host using multipass. the tutorial can be performed on Mac host too. for Windows users, you will need to install multipass and provision a Ubuntu 18.04 VM with multipass. The tutorial uses Ubuntu 18.04, if you don't have one, you can use - vmware workstation to create a Ubuntu guest O/S or - use multiplass shown in the following instruction, which is available for certain version of Windows, and Mac - alternatively you can use Virtualbox with Vagrant , with these you can have a shared folder between your host and guest Ubuntu O/S. Here you can find how to use virtualbox and vagrant. Verify your setup node -v npm -v Ubuntu Linux Setup for Windows download Windows multipass, head over to here . Installing Multipass for Windows Ubuntu Linux Setup for Macs download Macs multipass, head over to here . to create a default Ubuntu with - name: linux-vm - cpu : 4 cores - memory: 8GB - disk: 40 GB run the following command, and it will create a VM spec as of above. multipass launch -n linux-vm -m 8G -d 40G -c 4 vm info to find info about VMs multipass list get into vm shell to access the shell of Ubuntu VM multipass shell linux-vm install docker update existing package sudo apt update && sudo apt upgrade install a few prerequisite packages which let apt use packages over HTTPS sudo apt install apt-transport-https ca-certificates curl software-properties-common add the GPG key for the official Docker repository to your system curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - Add the Docker repository to APT sources sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable\" update the package database with the Docker packages from the newly added repo sudo apt update && sudo apt upgrade Make sure you are about to install from the Docker repo instead of the default Ubuntu repo apt-cache policy docker-ce install Docker sudo apt install docker-ce check Docker status sudo systemctl status docker check docker version docker version add your user for running docker commands sudo usermod -aG docker ${USER} to confirm user has been added id -nG Configure Docker insecure repo Edit /etc/docker/daemon.json and update the key \"insecure-registries\" { \"insecure-registries\" : [\"mycluster.icp:8500\"] } restart docker sudo systemctl restart docker test login to ICP docker repo, you will need to edit and update your /etc/hosts file to map your ICP 192.168.0.5 to mycluster.icp sample /etc/hosts # Your system has configured 'manage_etc_hosts' as True. # As a result, if you wish for changes to this file to persist # then you will need to either # a.) make changes to the master file in /etc/cloud/templates/hosts.debian.tmpl # b.) change or remove the value of 'manage_etc_hosts' in # /etc/cloud/cloud.cfg or cloud-config from user-data # 127.0.1.1 linux-vm linux-vm 127.0.0.1 localhost 192.168.0.5 mycluster.icp # The following lines are desirable for IPv6 capable hosts ::1 ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters ff02::3 ip6-allhosts docker login mycluster.icp:8500 clone the project clone the httpbin-wrapper sample project git clone https://github.com/ibmcloudprivate2/httpbin-wrapper.git cd httpbin-wrapper/ npm install create the .env cp .env.sample .env run the test using the .env file to run and test your app locally in the linux vm determine the IP assigned to the vm using multipass list multipass list Name State IPv4 Image linux-vm Running 192.168.64.7 Ubuntu 18.04 LTS login into the vm shell and run node -r dotenv/config server.js output: Your port is: 1323 Running on http:/0.0.0.0:1323 from another terminal or from browser use the following url based on the IP you obtained from multipass list curl http://192.168.64.7:1323/ output: {\"args\":{},\"data\":\"\",\"files\":{},\"form\":{},\"headers\":{\"Accept\":\"application/json\",\"Host\":\"httpbin.org\"},\"origin\":\"121.7.17.203, 121.7.17.203\",\"url\":\"https://httpbin.org/delay/1\"} Your environment is now ready for you to do nodejs development. to exit shell type exit in the multipass linux-vm shell stop the vm multipass stop linux-vm delete and clean vm multipass delete linux-vm multipass purge get help multipass help Using Vagrant for CentOS 7 Once you have virtualbox and vagrant installed, you can run the following commands that performs the following about the Vagrantfile - the VM is created using a box \"centos 7.6\" and using virtualbox as the cloud provider with 2 cpu, 4GB RAM - user Vagrant - and runs inline script to install docker - a initial Vagrantfile can be created with vagrant init centos/7 - cpu: 2, ram: 8 GB, change the VM spec accordingly in the Vagrantfile Vagrantfile runs inline script to - install docker - disable SELinux first time provisioning of machine cd mycentos vagrant up after the install finished it will reboot the machine, and you have a running centos where you ssh into machine shell as follows note : you will see the following message, you can ignore it. default: Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. default: Job for docker.service failed because the control process exited with error code. See \"systemctl status docker.service\" and \"journalctl -xe\" for details. vagrant ssh check cpu in centos cat /proc/cpuinfo check memory info cat /proc/meminfo shutdown machine vagrant halt power up machine vagrant up suspends the machine vagrant suspend restarts machine vagrant reload delete the machine vagrant destroy","title":"Prepare"},{"location":"prepare/#development-environment","text":"Level: Beginner Ensure your development environment has the following docker where you can build, run, push/pull images install node and npm IBM Cloud Private tools install cloudctl install kubectl In this tutorial, we will be doing our docker development on Ubuntun 18.04 and we will create a ubuntu VM on your machine host using multipass. the tutorial can be performed on Mac host too. for Windows users, you will need to install multipass and provision a Ubuntu 18.04 VM with multipass. The tutorial uses Ubuntu 18.04, if you don't have one, you can use - vmware workstation to create a Ubuntu guest O/S or - use multiplass shown in the following instruction, which is available for certain version of Windows, and Mac - alternatively you can use Virtualbox with Vagrant , with these you can have a shared folder between your host and guest Ubuntu O/S. Here you can find how to use virtualbox and vagrant.","title":"Development environment"},{"location":"prepare/#verify-your-setup","text":"node -v npm -v","title":"Verify your setup"},{"location":"prepare/#ubuntu-linux-setup-for-windows","text":"download Windows multipass, head over to here . Installing Multipass for Windows","title":"Ubuntu Linux Setup for Windows"},{"location":"prepare/#ubuntu-linux-setup-for-macs","text":"download Macs multipass, head over to here . to create a default Ubuntu with - name: linux-vm - cpu : 4 cores - memory: 8GB - disk: 40 GB run the following command, and it will create a VM spec as of above. multipass launch -n linux-vm -m 8G -d 40G -c 4","title":"Ubuntu Linux Setup for Macs"},{"location":"prepare/#vm-info","text":"to find info about VMs multipass list","title":"vm info"},{"location":"prepare/#get-into-vm-shell","text":"to access the shell of Ubuntu VM multipass shell linux-vm","title":"get into vm shell"},{"location":"prepare/#install-docker","text":"update existing package sudo apt update && sudo apt upgrade install a few prerequisite packages which let apt use packages over HTTPS sudo apt install apt-transport-https ca-certificates curl software-properties-common add the GPG key for the official Docker repository to your system curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - Add the Docker repository to APT sources sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable\" update the package database with the Docker packages from the newly added repo sudo apt update && sudo apt upgrade Make sure you are about to install from the Docker repo instead of the default Ubuntu repo apt-cache policy docker-ce install Docker sudo apt install docker-ce check Docker status sudo systemctl status docker check docker version docker version add your user for running docker commands sudo usermod -aG docker ${USER} to confirm user has been added id -nG","title":"install docker"},{"location":"prepare/#configure-docker-insecure-repo","text":"Edit /etc/docker/daemon.json and update the key \"insecure-registries\" { \"insecure-registries\" : [\"mycluster.icp:8500\"] } restart docker sudo systemctl restart docker test login to ICP docker repo, you will need to edit and update your /etc/hosts file to map your ICP 192.168.0.5 to mycluster.icp sample /etc/hosts # Your system has configured 'manage_etc_hosts' as True. # As a result, if you wish for changes to this file to persist # then you will need to either # a.) make changes to the master file in /etc/cloud/templates/hosts.debian.tmpl # b.) change or remove the value of 'manage_etc_hosts' in # /etc/cloud/cloud.cfg or cloud-config from user-data # 127.0.1.1 linux-vm linux-vm 127.0.0.1 localhost 192.168.0.5 mycluster.icp # The following lines are desirable for IPv6 capable hosts ::1 ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters ff02::3 ip6-allhosts docker login mycluster.icp:8500","title":"Configure Docker insecure repo"},{"location":"prepare/#clone-the-project","text":"clone the httpbin-wrapper sample project git clone https://github.com/ibmcloudprivate2/httpbin-wrapper.git cd httpbin-wrapper/ npm install create the .env cp .env.sample .env run the test using the .env file to run and test your app locally in the linux vm determine the IP assigned to the vm using multipass list multipass list Name State IPv4 Image linux-vm Running 192.168.64.7 Ubuntu 18.04 LTS login into the vm shell and run node -r dotenv/config server.js output: Your port is: 1323 Running on http:/0.0.0.0:1323 from another terminal or from browser use the following url based on the IP you obtained from multipass list curl http://192.168.64.7:1323/ output: {\"args\":{},\"data\":\"\",\"files\":{},\"form\":{},\"headers\":{\"Accept\":\"application/json\",\"Host\":\"httpbin.org\"},\"origin\":\"121.7.17.203, 121.7.17.203\",\"url\":\"https://httpbin.org/delay/1\"} Your environment is now ready for you to do nodejs development.","title":"clone the project"},{"location":"prepare/#to-exit-shell","text":"type exit in the multipass linux-vm shell","title":"to exit shell"},{"location":"prepare/#stop-the-vm","text":"multipass stop linux-vm","title":"stop the vm"},{"location":"prepare/#delete-and-clean-vm","text":"multipass delete linux-vm multipass purge","title":"delete and clean vm"},{"location":"prepare/#get-help","text":"multipass help","title":"get help"},{"location":"prepare/#using-vagrant-for-centos-7","text":"Once you have virtualbox and vagrant installed, you can run the following commands that performs the following about the Vagrantfile - the VM is created using a box \"centos 7.6\" and using virtualbox as the cloud provider with 2 cpu, 4GB RAM - user Vagrant - and runs inline script to install docker - a initial Vagrantfile can be created with vagrant init centos/7 - cpu: 2, ram: 8 GB, change the VM spec accordingly in the Vagrantfile Vagrantfile runs inline script to - install docker - disable SELinux","title":"Using Vagrant for CentOS 7"},{"location":"prepare/#first-time-provisioning-of-machine","text":"cd mycentos vagrant up after the install finished it will reboot the machine, and you have a running centos where you ssh into machine shell as follows note : you will see the following message, you can ignore it. default: Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. default: Job for docker.service failed because the control process exited with error code. See \"systemctl status docker.service\" and \"journalctl -xe\" for details. vagrant ssh check cpu in centos cat /proc/cpuinfo check memory info cat /proc/meminfo","title":"first time provisioning of machine"},{"location":"prepare/#shutdown-machine","text":"vagrant halt","title":"shutdown machine"},{"location":"prepare/#power-up-machine","text":"vagrant up","title":"power up machine"},{"location":"prepare/#suspends-the-machine","text":"vagrant suspend","title":"suspends the machine"},{"location":"prepare/#restarts-machine","text":"vagrant reload","title":"restarts machine"},{"location":"prepare/#delete-the-machine","text":"vagrant destroy","title":"delete the machine"},{"location":"python/","text":"setup python environment ubuntu comes with python3 by default, to check the version run the following command python3 -V in order to use different python environment for different project, the recommended way to create a virtual environment is to use the venv module, install as follow sudo apt install python3-venv -y Create a new directory for your Flask application and navigate into it mkdir my_flask_app cd my_flask_app Once inside the directory, run the following command to create your new virtual environment python3 -m venv venv The command above creates a directory called venv, which contains a copy of the Python binary, the Pip package manager, the standard Python library and other supporting files. You can use any name you want for the virtual environment. To start using this virtual environment, you need to activate it by running the activate script: source venv/bin/activate install Flask Now that the virtual environment is activated, you can use the Python package manager pip to install Flask pip install Flask Verify the installation with the following command which will print the Flask version python -m flask --version create a \"hello world\" flask app, hello.py touch hello.py enter the following content into hello.py from flask import Flask app = Flask(__name__) @app.route(\"/\") def greeting(): return \"<h1 style='color:green'>Hello World!</h1>\" if __name__ == \"__main__\": app.run(host='0.0.0.0') Testing the app python3 hello.py to test with browser, find your multipass VM IP, from another terminal, run multipass list sample Name State IPv4 Image linux-vm Running 192.168.64.7 Ubuntu 18.04 LTS use the browser and access http://192.168.64.7:5000 to serve as the site, we can use Gunicorn and then setup a WSGI Entry Point. pip install gunicorn create a WSGI entry point touch wsgi.py copy the following content into wsgi.py from hello import app if __name__ == \"__main__\": app.run() start the server gunicorn --bind 0.0.0.0:5000 wsgi:app Once you are done with your work, deactivate the environment, by typing deactivate and you will return to your normal shell. deactivate","title":"python flask"},{"location":"python/#setup-python-environment","text":"ubuntu comes with python3 by default, to check the version run the following command python3 -V in order to use different python environment for different project, the recommended way to create a virtual environment is to use the venv module, install as follow sudo apt install python3-venv -y Create a new directory for your Flask application and navigate into it mkdir my_flask_app cd my_flask_app Once inside the directory, run the following command to create your new virtual environment python3 -m venv venv The command above creates a directory called venv, which contains a copy of the Python binary, the Pip package manager, the standard Python library and other supporting files. You can use any name you want for the virtual environment. To start using this virtual environment, you need to activate it by running the activate script: source venv/bin/activate","title":"setup python environment"},{"location":"python/#install-flask","text":"Now that the virtual environment is activated, you can use the Python package manager pip to install Flask pip install Flask Verify the installation with the following command which will print the Flask version python -m flask --version create a \"hello world\" flask app, hello.py touch hello.py enter the following content into hello.py from flask import Flask app = Flask(__name__) @app.route(\"/\") def greeting(): return \"<h1 style='color:green'>Hello World!</h1>\" if __name__ == \"__main__\": app.run(host='0.0.0.0') Testing the app python3 hello.py to test with browser, find your multipass VM IP, from another terminal, run multipass list sample Name State IPv4 Image linux-vm Running 192.168.64.7 Ubuntu 18.04 LTS use the browser and access http://192.168.64.7:5000 to serve as the site, we can use Gunicorn and then setup a WSGI Entry Point. pip install gunicorn create a WSGI entry point touch wsgi.py copy the following content into wsgi.py from hello import app if __name__ == \"__main__\": app.run() start the server gunicorn --bind 0.0.0.0:5000 wsgi:app Once you are done with your work, deactivate the environment, by typing deactivate and you will return to your normal shell. deactivate","title":"install Flask"},{"location":"spring/","text":"","title":"Spring"},{"location":"swift/","text":"","title":"Swift"},{"location":"topics/","text":"Introduction We will do a quick overview of the following and have a hands-on of working with a simple application name NodeJS. Containers Kubernetes Microservice Microservice Architecture DevSecOps Resources Code patterns IBM Architecture Center Istio : Connect, secure, control, and observe services. Knative : Kubernetes-based platform to build, deploy, and manage modern serverless workloads. Kabanero : modern microservices-based framework that provides end-to-end solution that enables you to architect, build, deploy, and manage the lifecycle of Kubernetes-based applications Kubernetes Helm Chart Curated application for Kubernetes Singapore Exchange (SGX) IBM Cloud Private Use Case migrating monolith to microservice","title":"Topics"},{"location":"topics/#introduction","text":"We will do a quick overview of the following and have a hands-on of working with a simple application name NodeJS. Containers Kubernetes Microservice Microservice Architecture DevSecOps","title":"Introduction"},{"location":"topics/#resources","text":"Code patterns IBM Architecture Center Istio : Connect, secure, control, and observe services. Knative : Kubernetes-based platform to build, deploy, and manage modern serverless workloads. Kabanero : modern microservices-based framework that provides end-to-end solution that enables you to architect, build, deploy, and manage the lifecycle of Kubernetes-based applications Kubernetes Helm Chart Curated application for Kubernetes Singapore Exchange (SGX) IBM Cloud Private Use Case migrating monolith to microservice","title":"Resources"},{"location":"ocp/cli/","text":"You can find a summary of the key commands covered below, along with some related commands. To see more information on each oc command, run it with the --help option. oc login: Log in to your OpenShift cluster and save the session token for subsequent use. You will be prompted for the user name and password or directed to a web console page where you can obtain a token you must then use to use to login from the command line. The web page will require you to first login in to the web console if you are not already logged in. oc login : Log in to a specific OpenShift cluster. You will need to specify the name of the server as argument the first time you are using it, or if switching back to it after having used a different cluster. oc login --username : Log in to your OpenShift cluster as a specific user. oc login --username --password : Log in to your OpenShift cluster as a specific user and supply the password on the command line. Note that this is not recommended for real systems as your password may be logged or retained in command history. oc login --token : Log in to your server using a token for an existing session. oc logout: Log out of the active session by clearing the session token. oc whoami: Show the name of the user for the current login session. oc whoami --token: Show the token for the current login session. oc whoami --show-server: Show which OpenShift cluster you are logged into. oc whoami --show-context: Shows the context for the current session. This will include details about the project, server and name of user, in that order. oc config get-clusters: Show a list of all OpenShift clusters ever logged in to. oc config get-contexts: Show a list of contexts for all sessions ever created. For each context listed, this will include details about the project, server and name of user, in that order. oc adm policy add-role-to-user edit -n : Add another user to a project so that they can work within the project, including creating new deployments or deleting applications. oc adm policy add-role-to-user view -n : Add another user to a project but such that they can only view what is in the project. oc adm policy add-role-to-user admin -n : Add another user to a project such that they are effectively a joint owner of the project and have administration rights over it, including the ability to delete the project.","title":"Cli"}]}